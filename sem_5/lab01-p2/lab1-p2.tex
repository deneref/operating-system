\documentclass[12pt]{report}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
%\usepackage[14pt]{extsizes}
\usepackage{listings}
\usepackage{xcolor}

% Для измененных титулов глав:
\usepackage{titlesec, blindtext, color} % подключаем нужные пакеты
\definecolor{gray75}{gray}{0.75} % определяем цвет
\newcommand{\hsp}{\hspace{20pt}} % длина линии в 20pt
% titleformat определяет стиль
\titleformat{\chapter}[hang]{\Huge\bfseries}{\thechapter\hsp\textcolor{gray75}{|}\hsp}{0pt}{\Huge\bfseries}

%отступы по краям
\usepackage{geometry}
\geometry{verbose, a4paper,tmargin=2cm, bmargin=2cm, rmargin=1.5cm, lmargin = 3cm}
% межстрочный интервал
\usepackage{setspace}
\onehalfspacing
\usepackage{float}
% plot
\usepackage{pgfplots}
\usepackage{filecontents}
\usepackage{amsmath}
\usepackage{tikz,pgfplots}
\usetikzlibrary{datavisualization}
\usetikzlibrary{datavisualization.formats.functions}

\usepackage{graphicx}
\graphicspath{{src/}}
\DeclareGraphicsExtensions{.pdf,.png,.jpg}

\usepackage{geometry}
\geometry{verbose, a4paper,tmargin=2cm, bmargin=2cm, rmargin=1.5cm, lmargin = 3cm}
\usepackage{indentfirst}
\setlength{\parindent}{1.4cm}


\begin{document}
%\def\chaptername{} % убирает "Глава"
\begin{titlepage}
	\centering
	{\scshape\LARGE МГТУ им. Баумана \par}
	\vspace{3cm}
	{\scshape\Large Лабораторная работа №1 ч.2.\par}
	\vspace{0.5cm}	
	{\scshape\Large По курсу: "Операционные системы"\par}
	\vspace{1.5cm}
	\centering
	 {\huge\bfseries Функции обработчика системного таймера. Пересчет динамических приоритетов\par}
	\vspace{2cm}
	\Large Работу выполнил: Мокеев Даниил, ИУ7-56\par
	\vspace{0.5cm}
	\Large Преподаватель:  Рязанова Н.Ю.\par

	\vfill
	\large \textit {Москва, 2020} \par
\end{titlepage}


\newpage

\chapter{Функции обработчика прерываний от системного таймера}
\section{Unix}
\subsection{По тику}
\begin{itemize}
	\item Инкремент	счетчика использования процессора текущим процессом;
	\item инкремент часов и других таймеров системы;
	\item декремент счетчика времени, оставшегося до отправления на выполнение отложенных вызовов и отправка отложенных вызовов на выполнение, при достижении нулевого значения счетчика;
	\item декремент кванта.
\end{itemize}
\subsection{По главному тику}
\begin{itemize}
	\item	Добавление в очередь отложенных вызовов функций планировщика;
	\item	пробуждение системных процессов, таких как swapper и pagedaemon;
	
	\item	декремент счетчиков времени, оставшегося до отправления одного из сигналов:
	\begin{itemize}
		\item	SIGALRM — сигнал будильника реального времени, который отправляется по истечении заданного промежутка реального времени;
		\item	SIGPROF —  сигнал, посылаемый процессу по истечении времени заданном в таймере профилирования;
		\item	SIGVTALRM — сигнал будильника виртуального времени,
		который измеряет время работы процесса в режиме задачи.
	\end{itemize}
\end{itemize}

\subsection{По кванту}

\begin{itemize}
	\item При превышении текущим процессом выделенного кванта, отправка сигнала SIGXCPU этому процессу.
\end{itemize}

\section{Windows}
\subsection{По тику}
\begin{itemize}
	\item Инкремент счетчика системного времени;
	\item декремент счетчиков отложенных задач;
	\item декремент остатка кванта текущего потока;
	\item активация обработчика ловушки профилирования ядра.
\end{itemize}
\subsection{По главному тику}
\begin{itemize}
	\item Инициализация диспетчера настройки баланса путем освобождения объекта «событие», на котором он ожидает.

\end{itemize}
\subsection{По кванту}
\begin{itemize}
	\item Инициализация диспетчеризации потоков путем добавления соответствующего объекта DPC в очередь.
\end{itemize}

\chapter{Пересчет динамических приоритетов}
\section{Unix}
В Unix планировщик предоставляет процессор каждому процессу системы на небольшой период времени, после чего производит переключение на следующий процесс. Этот период называется \textbf{квантом времени}.

Переключение контекста - на самом низком уровне планировщик заставляет процессор производить переключения от одного процесса к другому.

Классическое ядро UNIX является \textbf{строго невытесняемым}. Это означает, что если процесс выполняется в режиме ядра, то ядро не заставит этот процесс уступить процессорное время какому-либо более приоритетному процессу. Выполняющийся процесс может освободить процессор в случае своего блокирования в ожидании ресурса, иначе он может быть вытеснен при переходе в режим задачи. Такая реализация ядра позволяет решить множество проблем синхронизации, связанных с доступом нескольких процессов к одним и тем же структурам данных ядра.

В современных системах Unix ядро является вытесняющим – процесс в режиме ядра может быть вытеснен более приоритетным процессом в режиме ядра.

\subsection{Приоритеты процессов}
Приоритет процесса в UNIX задается числом в диапазоне от 0 до 127, причем чем меньше значение, тем выше приоритет. Приоритеты 0–49 зарезервированы ядром операционной системы, прикладные процессы могут обладать приоритетом в диапазоне от 50 до 127.

Структура proc содержит следующие поля, относящиеся к приоритетам:
\begin{itemize}
	\item p\textunderscore pri — текущий приоритет планирования;
	
	\item p\textunderscore usrpri — приоритет режима задачи;
	
	\item p\textunderscore cpu — результат последнего измерения использования процессора;
	
	\item p\textunderscore nice — фактор «любезности», устанавливаемый пользователем.
	
\end{itemize}

\begin{table}
\centering
	\begin{tabular}{|l| c | c|} 
		\hline
		Событие & Приоритет 4.3BSD UNIX & Приоритет SCO UNIX\\ [0.5ex] 
		\hline\hline
		Ожидание загрузки в память страницы & 0 & 95 \\
		\hline
		Ожидание индексного дескриптора & 10 & 88 \\
		\hline
		Ожидание ввода–вывода & 20 & 81 \\
		\hline
		Ожидание буфера & 30 & 80\\
		\hline
		Ожидание терминального ввода & 30 & 75\\
		\hline
		Ожидание терминального вывода & 30 & 74\\
		\hline
 		Ожидание завершения выполнения &30 & 43\\
 		\hline
 		Ожидание события &30 & 66\\
 		\hline
	\end{tabular}
\caption{Приоритеты сна}
\end{table}
Ядро системы связывает приоритет сна с событием или ожидаемым ресурсом, из-за которого процесс может заблокироваться. Приоритет сна является величиной, определяемой для ядра, и потому лежит в диапазоне 0-49(Значение приоритета сна для терминального ввода - 28, для операций ввода-вывода - 20). Когда блокированный процесс просыпается, ядро устанавливает p\textunderscore pri, равное приоритету сна события или ресурса, на котором он был заблокирован, следовательно, такой процесс будет назначен на выполнение раньше, чем другие процессы в режиме задачи. В таблице 2.1 приведены значения приоритетов сна для систем 4.3BSD UNIX и SCO UNIX (OpenServer 5.0). Такой подход позволяет системным вызовам быстрее завершать свою работу. По завершении процессом системного вызова его приоритет сбрасывается в значение текущего приоритета в режиме задачи. Если при этом приоритет окажется ниже, чем приоритет другого запущенного процесса, ядро произведет переключение контекста.

Планировщик использует поле p\textunderscore pri для принятия решения о том, какой процесс отправить на выполнение. Значения p\textunderscore pri и p\textunderscore usrpri идентичны, когда процесс находится в режиме задачи. Когда процесс просыпается после блокировки в системном вызове, его приоритет временно повышается. Планировщик использует p\textunderscore usrpri для хранения приоритета, который будет назначен процессу при переходе из режима ядра в режим задачи, а p\textunderscore pri — для хранения временного приоритета для выполнения в режиме ядра.

Приоритет в режиме задачи зависит от «любезности» и последней измеренной величины использования процессора. Степень любезности
—	это число в диапазоне от 0 до 39 со значением 20 по умолчанию. Степень любезности называется так потому, что одни пользователи могут быть поставлены в более выгодные условия другими пользователями посредством увеличения кем-либо из последних значения уровня любезности для своих менее важных процессов.

Системы разделения времени стараются выделить процессорное время таким образом, чтобы все процессы системы получили его в примерно равных количествах, что требует слежения за использованием процессора. Поле p\textunderscore cpu содержит величину последнего измерения использования процессора процессом. При создании процесса это поле инициализируется нулем. На каждом тике обработчик таймера увеличивает p\textunderscore cpu на единицу для текущего процесса, вплоть до максимального значения — 127. Каждую секунду ядро вызывает процедуру schedcpu, которая уменьшает значение p\textunderscore cpu каждого процесса исходя из фактора «полураспада». В 4.3 BSD для расчета применяется формула:

\begin{center}
	$dacay = \frac{2 \cdot load\textunderscore average}{2 \cdot load\textunderscore average +1 }$,
\end{center}
где load\textunderscore average — это среднее количество процессов в состоянии готовности за последнюю секунду.

Кроме того, процедура schedcpu также пересчитывает приоритеты режима задачи всех процессов по формуле:
\begin{center}
	$p_{u}srpri = PUSER + \frac{p \textunderscore cpu}{4} + 2
	\cdot p \textunderscore nice$,
\end{center}
где PUSER — базовый приоритет в режиме задачи, равный 50.

Таким образом, если процесс до вытеснения другим процессом использовал большое количество процессорного времени, его p\textunderscore cpu будет увеличен, что приведет к увеличению значения p\textunderscore usrpri, и, следовательно, к понижению приоритета.

Чем дольше процесс простаивает в очереди на выполнение, тем меньше его p\textunderscore cpu. Это позволяет предотвратить зависания низкоприоритетных процессов. Если процесс большую часть времени выполнения тратит на ожидание ввода-вывода, то он остается с высоким приоритетом.

В системах разделения времени фактор использования процессора обеспечивает справедливость при планировании процессов. Фактор полураспада обеспечивает экспоненциально взвешанное среднее значение использования процессора в течение функционирования процесса. Формула, применяемая в SVR3 имеет недостаток: вычисляя простое экспоненциальное среднее, она способствует росту приоритетов при увеличении загрузки системы.
\section{Windows}
В системе Windows реализовано вытесняющее планирование на основе уровней приоритета, при которой выполняется готовый поток с наивысшим приоритетом.

Если поток с более высоким приоритетом готов к выполнению, текущий поток вытесняется планировщиком, даже если квант текущего потока не истёк.

Процессорное время, выделенное на выполнение потока, называется квантом. Если поток с более высоким приоритетом готов к выполнению, текущий поток вытесняется планировщиком, даже если квант текущего потока не истек.

Уровни приоритета потоков назначаются Windows API и ядром Windows. Сначала WinAPI систематизирует процессы по классу приоритета (присваивается при создании), затем назначается относительный приоритет отдельных потоков внутри этих процессов.

\newpage
В Windows за планирование отвечает совокупность процедур ядра, называемая диспетчером ядра. Диспетчеризация может быть вызвана, если:
\begin{enumerate}
	\item Поток готов к выполнению;
	\item истек квант текущего потока;
	\item поток завершается или переходит в состояние ожидания;
	\item изменился приоритет потока;
	\item изменилась привязка потока к процессору.
\end{enumerate}
\subsection{Приоритеты потоков}
В системе предусмотрено 32 уровня приоритетов: уровни реального времени (16–31), динамические уровни (1–15) и системный уровень (0).
Уровни приоритета потоков назначаются Windows API и ядром операционной системы.

Windows API сортирует процессы по классам приоритета, которые были назначены при их создании:
\begin{enumerate}
	\item	реального времени — Real-time (4);
	\item	высокий — High (3);
	\item	выше обычного — Above Normal (6);
	\item	обычный — Normal (2);
	\item	ниже обычного — Below Normal (5);
	\item	простой — Idle (1)
\end{enumerate}

\begin{table}[H]
	\centering
	\begin{tabular}{|l| c | c | c | c | c | c |} 
		\hline
		Класс приоритета & Realtime &  High & Above & Normal & Below normal & Idle\\ [0.5ex] 
		\hline\hline
		Time Critical (+насыщение) & 31 & 15 & 15 & 15 & 15 & 15 \\
		\hline
		Highest (+2) & 26 & 15 & 12 & 10 & 8 & 6 \\
		\hline
		Above normal (+1) & 25 & 14 & 11 & 9 & 7 & 5\\
		\hline
		Normal (0) & 24 & 13 & 10 & 8 & 6 & 4\\
		\hline
		Below Normal (-1) & 23 & 12 & 9 & 7 & 5 & 3\\
		\hline
		Lowest (-2) & 22 & 11 & 8 & 6 & 4 & 2\\
		\hline
		Idle (-насыщение) & 16 & 1 & 1 & 1 & 1 & 1\\
		\hline
	\end{tabular}
	\caption{Отображение приоритетов ядра Windows на WIndows API}
\end{table}

\newpage
Затем назначается относительный приоритет потоков в рамках процессов:

\begin{itemize}
	\item	критичный по времени — Time-critical (15);
	\item	наивысший — Highest (2);
	\item	выше обычного — Above-normal (1);
	\item	обычный — Normal (0);
	\item	ниже обычного — Below-normal (-1);
	\item	низший — Lowest (-2);
	\item	простой — Idle (-15).
\end{itemize}
	
Относительный приоритет — это приращение к базовому приоритету процесса.

Соответствие между приоритетами Windows API и ядра системы приведено в таблице 2.2.

Каким бы образом ни формировался приоритет потока, с точки зрения планировщика Windows важно только значение приоритета.

Процесс обладает только базовым приоритетом, тогда как поток имеет базовый, который наследуется от приоритета процесса, и текущий приоритет. Операционная система может на короткие
интервалы времени повышать приоритеты потоков из динамического диапазона, но никогда не регулирует приоритеты потоков в диапазоне реального времени.

Приложения пользователя запускаются, как правило, с базовым приоритетом Normal. Некоторые системные процессы имеют приоритет выше 8, следовательно, это гарантирует, что потоки в этих процессах будут запускаться с более высоким приоритетом.

Система динамически повышает приоритет текущего потока в следующих случаях:
\begin{itemize}
	\item По завершении операции ввода-вывода;
	\item по окончании ожидания на событии или семафоре исполнительной системы;
	\item по окончании ожидания потоками активного процесса;
	\item при пробуждении GUI-потоков из-за операции с окнами;
	\item если поток, готовый к выполнению, задерживается из-за нехватки процессорного времени.
\end{itemize}

Динамическое повышение приоритета применяется только к потокам из динамического диапазона (1–15) и, независимо от приращения, приоритет потока не может оказаться выше 15.

\subsection{Повышение приоритета по завершении операции ввода-вывода}

По окончании определенных операций ввода-вывода Windows временно повышает приоритет потоков и потоки,
ожидающие завершения этих операций, имеют больше шансов немедленно возобновить выполнение и обработать полученные от устройств ввода-вывода данные.

Драйвер устройства ввода-вывода через функцию IoCompleteRequest указывает на необходимость динамического повышения приоритета после выполнения соответствующего запроса.

В таблице 2.3 приведены приращения приоритетов.

\begin{table}[H]
	\centering
	\begin{tabular}{|l| c |} 
		\hline
		Устройство & Повышение приоритета\\ [0.5ex] 
		\hline\hline
		Жесткий диск, привод компакт-дисков,\\ параллельный порт, видеоустройство & 1 \\
		\hline
		Сеть, почтовый слот, именованный канал, последовательный порт & 2 \\
		\hline
		Клавиатура, мышь & 6\\
		\hline
		Звуковое устройство & 8\\
		\hline
	\end{tabular}
	\caption{Рекомендованные значения повышения приоритета}
\end{table}
	
Приоритет потока всегда повышается относительно базового приоритета. На рисунке 2.1 показано, что после повышения приоритета поток в течение одного кванта выполняется с повышенным приоритетом, а затем приоритет снижается на один уровень с каждым последующим квантом. Цикл продолжается до тех пор, пока приоритет не снизится до базового.

\begin{figure}[h]
	\centering
	{\includegraphics[scale=0.9]{ris1.png}} 
	\caption{Динамическое изменение приоритета}
	\label{ris1}
\end{figure}

\subsection{Повышение приоритета по окончании ожидания на событии или семафоре}
Если ожидание потока на событии системы или «семафоре» успешно завершается из-за вызова SetEvent, PulseEvent или ReleaseSemaphore, его приоритет повышается на 1.

Такая регулировка, как и в случае с окончанием операции ввода-вывода, позволяет равномернее распределить процессорное время
—	потокам, блокируемым на событиях, процессорное время требуется реже, чем остальным. В данном случае действуют те же правила динамического повышения приоритета.

К потокам, пробуждающимся в результате установки события вызовом функций NtSetEventBoostPriority и KeSetEventBoostPriority, повышение приоритета применяется особым образом.

\subsection{Повышение приоритета по окончании ожидания потоками активного процесса}

Если поток в активном процессе завершает ожидание на объекте ядра, функция ядра KiUnwaitThread повышает его текущий приоритет на величину значения PsPrioritySeparation. PsPriorituSeparation — это индекс
в таблице квантов, с помощью которой выбираются величины квантов для потоков активных процессов. Какой процесс является в данный момент активным, определяет подсистема управления окнами.

В данном случае приоритет повышается для создания преимуществ интерактивным приложениям по окончании ожидания, в результате
чего повышаются шансы на немедленное возобновление потока приложения. Важной особенностью данного вида динамического
повышения приоритета является то, что он поддерживается всеми системами Windows и не может быть отключен даже функцией SetThreadPriorityBoost.

\subsection{Повышение приоритета при пробуждении GUIпотоков}
Приоритет потоков окон пользовательского интерфейса повышается на 2 после их пробуждения из-за активности подсистемы управления окнами. Приоритет повышается по той же причине, что и в предыдущем случае, — для увеличения отзывчивости интерактивных приложений.

\subsection{Повышение приоритета при нехватке процессорного времени}
Раз в секунду диспетчер настройки баланса — системный поток, предназначенный	для	выполнения	функций	управления	памятью	— сканирует очереди готовых потоков и ищет потоки, которые находятся в состоянии готовности в течение примерно 4 секунд. Диспетчер настройки баланса повышает приоритет таких потоков до 15. Причем в Windows 2000 и Windows XP квант потока удваивается относительно кванта процесса, а в Windows Server 2003 квант устанавливается равным 4 секундам. По истечении кванта приоритет потока снижается до исходного уровня. Если потоку все еще не хватило процессорного времени, то после снижения приоритета он возвращается в очередь готовых процессов. Через 4 секунды он может снова получить повышение приоритета.

Чтобы свести к минимуму расход процессорного времени, диспетчер настройки баланса сканирует только 16 готовых потоков за раз, а повышает приоритет не более чем у 10 потоков за раз.

Диспетчер настройки баланса не решает всех проблем с
приоритетами потоков, однако позволяет потокам, которым не хватает процессорного времени, получить его.

\subsection{Уровни запросов прерываний}
Windows использует схему приоритетов прерываний, называемую уровни запросов прерываний (IRQL). Внутри ядра IRQL представляются в виде номеров от 0 до 31 для систем x86. Ядро определяет стандартный набор IRQL для программных прерываний, а HAL связывает IRQL с номерами аппаратных прерываний (см. рис. 2.2).

\begin{figure}[h]
	\centering
	{\includegraphics[scale=0.9]{ris2.png}} 
	\caption{Уровни запросов прерываний}
	\label{ris2}
\end{figure}

Прерывания обслуживаются в порядке их приоритета. Прерывания с большим приоритетом вытесняют прерывания с меньшим приоритетом.
При возникновении прерывания с высоким приоритетом процессор сохраняет информацию о состоянии прерванного потока и активизирует сопоставленный с данным прерыванием диспетчер ловушки. Последний повышает IRQL и вызывает процедуру обслуживания прерывания — ISR.

После выполнения ISR диспетчер прерывания понижает IRQL процессора до исходного уровня и загружает сохраненные ранее данные о состоянии машины. Прерванный поток возобновляется с той точки, где он был прерван. Когда ядро понижает IRQL, могут начать обрабатываться ранее замаскированные прерывания с более низким приоритетом. Тогда вышеописанный процесс повторяется ядром для обработки и этих прерываний.

\chapter{Заключение}
Операционные системы UNIX и Windows являются системами разделения времени с вытеснением. В связи с этим обработчики прерываний от системных таймеров в них выполняют схожие
функции:

\begin{itemize}
	\item Инкремент счетчика системного времени;
	\item декремент кванта;
	\item добавление функций планировщика в очередь отложенных вызовов;
	\item декремент счетчиков времени, оставшегося до выполнения отложенных вызовов;
	\item отправка отложенных действий на выполнение.
\end{itemize}
Windows и Unix обработчик прерывания системного таймера выполняет очень похожие функции т.к обе эти системы являются системами разделения времени. Общие функции обработчика: счет тиков системного времени, декремент кванта текущего потока, наблюдение за списком отложенных вызовов.

Системы планирования в этих ОС различаются: Windows - полностью вытесняющая, Unix - строго невытесняющая.

\end{document}
